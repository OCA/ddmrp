# Copyright 2019-20 ForgeFlow S.L. (http://www.forgeflow.com)
# License LGPL-3.0 or later (https://www.gnu.org/licenses/lgpl.html).

import logging
import operator as py_operator
from collections import defaultdict
from datetime import datetime, timedelta
from math import pi

from odoo import _, api, fields, models
from odoo.exceptions import ValidationError
from odoo.tools import float_compare, float_round

_logger = logging.getLogger(__name__)
try:
    from bokeh.plotting import figure
    from bokeh.embed import components
    from bokeh.models import Legend, ColumnDataSource, LabelSet
    from bokeh.models import HoverTool, DatetimeTickFormatter
except (ImportError, IOError) as err:
    _logger.debug(err)


OPERATORS = {
    "<": py_operator.lt,
    ">": py_operator.gt,
    "<=": py_operator.le,
    ">=": py_operator.ge,
    "==": py_operator.eq,
    "!=": py_operator.ne,
}


_PRIORITY_LEVEL = [("1_red", "Red"), ("2_yellow", "Yellow"), ("3_green", "Green")]

DDMRP_COLOR = {
    "0_dark_red": "#8B0000",
    "1_red": "#ff0000",
    "2_yellow": "#ffff00",
    "3_green": "#33cc33",
}


class StockBuffer(models.Model):
    _name = "stock.buffer"
    _description = "Stock Buffer"
    _order = "planning_priority_level asc, net_flow_position asc"

    @api.model
    def default_get(self, fields):
        res = super().default_get(fields)
        warehouse = None
        if "warehouse_id" not in res and res.get("company_id"):
            warehouse = self.env["stock.warehouse"].search(
                [("company_id", "=", res["company_id"])], limit=1
            )
        if warehouse:
            res["warehouse_id"] = warehouse.id
            res["location_id"] = warehouse.lot_stock_id.id
        return res

    name = fields.Char(
        string="Name",
        copy=False,
        required=True,
        default=lambda self: self.env["ir.sequence"].next_by_code("stock.buffer"),
    )
    active = fields.Boolean(default=True)
    warehouse_id = fields.Many2one(
        comodel_name="stock.warehouse",
        string="Warehouse",
        ondelete="cascade",
        required=True,
    )
    location_id = fields.Many2one(
        comodel_name="stock.location",
        string="Location",
        ondelete="cascade",
        required=True,
    )
    product_id = fields.Many2one(
        comodel_name="product.product",
        string="Product",
        domain=[("type", "=", "product")],
        ondelete="cascade",
        required=True,
    )
    product_uom = fields.Many2one(
        comodel_name="uom.uom",
        string="Product Unit of Measure",
        related="product_id.uom_id",
        readonly=True,
        required=True,
        default=lambda self: self._context.get("product_uom", False),
    )
    # TODO: fix in method _compute_procure_recommended_qty.
    # not sure maybe they are useful for tweak batches like in multi level mrp
    procure_min_qty = fields.Float(
        string="Minimum Procure Batch",
        digits="Product Unit of Measure",
        help="Minimum qty for a single procurement",
    )
    procure_max_qty = fields.Float(
        string="Maximum Procure Batch",
        digits="Product Unit of Measure",
        help="Maximum qty for a single procurement",
    )
    qty_multiple = fields.Float(
        string="Qty Multiple",
        digits="Product Unit of Measure",
        default=1,
        required=True,
        help="The procurement quantity will be rounded up to this multiple. "
        "If it is 0, the exact quantity will be used.",
    )
    group_id = fields.Many2one(
        comodel_name="procurement.group",
        string="Procurement Group",
        copy=False,
        help="Moves created through this buffer will be put in this "
        "procurement group. If none is given, the moves generated by "
        "stock rules will be grouped into one big picking.",
    )
    company_id = fields.Many2one(
        comodel_name="res.company",
        string="Company",
        required=True,
        default=lambda self: self.env.company,
    )
    # TODO: rename to manual LT ??
    lead_days = fields.Integer(
        "Lead Time (Distributed)",
        default=1,
        help="Lead time for distributed products.",
    )

    _sql_constraints = [
        (
            "qty_multiple_check",
            "CHECK( qty_multiple >= 0 )",
            "Qty Multiple must be greater than or equal to zero.",
        ),
    ]

    def _quantity_in_progress(self):
        """Return Quantities that are not yet in virtual stock but should
        be deduced from buffers (example: purchases created from buffers)"""
        res = dict(self.mapped(lambda x: (x.id, 0.0)))
        polines = self.env["purchase.order.line"].search(
            [
                ("state", "in", ("draft", "sent", "to approve")),
                ("buffer_ids", "in", self.ids),
            ]
        )
        for poline in polines:
            for buffer in poline.buffer_ids:
                res[buffer.id] += poline.product_uom._compute_quantity(
                    poline.product_qty, buffer.product_uom, round=False
                )
        return res

    def action_view_purchase(self):
        action = self.env.ref("purchase.purchase_rfq")
        result = action.read()[0]
        # Remove the context since the action basically display RFQ and not PO.
        result["context"] = {}
        order_line_ids = self.env["purchase.order.line"].search(
            [("buffer_ids", "in", self.ids)]
        )
        purchase_ids = order_line_ids.mapped("order_id")
        result["domain"] = [("id", "in", purchase_ids.ids)]
        return result

    @api.constrains("product_id")
    def _check_product_uom(self):
        if any(
            buffer.product_id.uom_id.category_id != buffer.product_uom.category_id
            for buffer in self
        ):
            raise ValidationError(
                _(
                    "You have to select a product unit of measure that is in"
                    "the same category than the default unit of"
                    "measure of the product"
                )
            )

    @api.onchange("warehouse_id")
    def onchange_warehouse_id(self):
        if self.warehouse_id:
            self.location_id = self.warehouse_id.lot_stock_id.id

    @api.onchange("product_id")
    def onchange_product_id(self):
        if self.product_id:
            self.product_uom = self.product_id.uom_id.id
            return {
                "domain": {
                    "product_uom": [
                        ("category_id", "=", self.product_id.uom_id.category_id.id)
                    ]
                }
            }
        return {"domain": {"product_uom": []}}

    def _prepare_procurement_values(
        self, product_qty, date=False, group=False,
    ):
        """ Prepare specific key for moves or other components that will be
        created from a stock rule comming from a buffer. This method could
        be override in order to add other custom key that could
        be used in move/po creation.
        """
        return {
            "date_planned": date or self._get_date_planned(),
            "warehouse_id": self.warehouse_id,
            "buffer_id": self,
            "company_id": self.company_id,
            "group_id": group or self.group_id,
        }

    # MANUAL PROCUREMENT AND UOM

    def _get_date_planned(self):
        self.ensure_one()
        dlt = int(self.dlt)
        # For purchased items we always consider calendar days,
        # not work days.
        if (
            self.warehouse_id.calendar_id
            and self.buffer_profile_id.item_type != "purchased"
        ):
            dt_planned = self.warehouse_id.wh_plan_days(datetime.now(), dlt)
        else:
            dt_planned = fields.date.today() + timedelta(days=dlt)
        return fields.Date.to_date(dt_planned)

    procure_recommended_qty = fields.Float(
        string="Procure Recommendation",
        compute="_compute_procure_recommended_qty",
        store=True,
    )
    procure_uom_id = fields.Many2one(comodel_name="uom.uom", string="Procurement UoM",)

    @api.constrains("product_id", "procure_uom_id")
    def _check_procure_uom(self):
        if any(
            buffer.product_uom
            and buffer.procure_uom_id
            and buffer.product_uom.category_id != buffer.procure_uom_id.category_id
            for buffer in self
        ):
            raise ValidationError(
                _(
                    "Error: The product default Unit of Measure and the "
                    "procurement Unit of Measure must be in the same category."
                )
            )

    # STOCK INFORMATION:

    product_location_qty = fields.Float(
        string="Quantity On Location", compute="_compute_product_available_qty"
    )
    incoming_location_qty = fields.Float(
        string="Incoming On Location", compute="_compute_product_available_qty"
    )
    outgoing_location_qty = fields.Float(
        string="Outgoing On Location", compute="_compute_product_available_qty"
    )
    virtual_location_qty = fields.Float(
        string="Forecast On Location", compute="_compute_product_available_qty"
    )
    product_location_qty_available_not_res = fields.Float(
        string="Quantity On Location (Unreserved)",
        compute="_compute_product_available_qty",
    )

    def _compute_product_available_qty(self):
        operation_by_location = defaultdict(lambda: self.env["stock.buffer"])
        for rec in self:
            operation_by_location[rec.location_id] |= rec
        for location_id, buffer_in_location in operation_by_location.items():
            products = (
                buffer_in_location.mapped("product_id")
                .with_context(location=location_id.id)
                ._compute_quantities_dict(
                    lot_id=self.env.context.get("lot_id"),
                    owner_id=self.env.context.get("owner_id"),
                    package_id=self.env.context.get("package_id"),
                )
            )
            products_not_res = (
                buffer_in_location.mapped("product_id")
                .with_context(location=location_id.id)
                ._compute_product_available_not_res_dict()
            )
            for buffer in buffer_in_location:
                product = products[buffer.product_id.id]
                product_not_res = products_not_res[buffer.product_id.id]
                buffer.update(
                    {
                        "product_location_qty": product["qty_available"],
                        "incoming_location_qty": product["incoming_qty"],
                        "outgoing_location_qty": product["outgoing_qty"],
                        "virtual_location_qty": product["virtual_available"],
                        "product_location_qty_available_not_res": product_not_res[
                            "qty_available_not_res"
                        ],
                    }
                )

    # PURCHASES LINK:

    purchase_line_ids = fields.Many2many(
        comodel_name="purchase.order.line",
        string="Purchase Order Lines",
        copy=False,
        readonly=True,
    )

    # MRP LINK:

    def action_view_mrp_productions(self):
        action = self.env.ref("mrp.mrp_production_action")
        result = action.read()[0]
        result["context"] = {}
        mrp_production_ids = self.env["mrp.production"].search(
            [("buffer_id", "=", self.id)]
        )
        result["domain"] = [("id", "in", mrp_production_ids.ids)]
        return result

    # DDMRP SPECIFIC:

    @api.depends(
        "dlt",
        "adu",
        "buffer_profile_id.lead_time_id.factor",
        "red_override",
        "buffer_profile_id.variability_id.factor",
        "product_uom.rounding",
        "lead_days",
        "product_id.seller_ids.delay",
    )
    def _compute_red_zone(self):
        for rec in self:
            if rec.replenish_method in ["replenish", "min_max"]:
                rec.red_base_qty = float_round(
                    rec.dlt * rec.adu * rec.buffer_profile_id.lead_time_id.factor,
                    precision_rounding=rec.product_uom.rounding,
                )
                rec.red_safety_qty = float_round(
                    rec.red_base_qty * rec.buffer_profile_id.variability_id.factor,
                    precision_rounding=rec.product_uom.rounding,
                )
                rec.red_zone_qty = rec.red_base_qty + rec.red_safety_qty
            else:
                rec.red_zone_qty = rec.red_override

    @api.depends(
        "dlt",
        "adu",
        "buffer_profile_id.lead_time_id.factor",
        "order_cycle",
        "minimum_order_quantity",
        "product_uom.rounding",
        "green_override",
        "top_of_yellow",
    )
    def _compute_green_zone(self):
        for rec in self:
            if rec.replenish_method in ["replenish", "min_max"]:
                # Using imposed or desired minimum order cycle
                rec.green_zone_oc = float_round(
                    rec.order_cycle * rec.adu,
                    precision_rounding=rec.product_uom.rounding,
                )
                # Using lead time factor
                rec.green_zone_lt_factor = float_round(
                    rec.dlt * rec.adu * rec.buffer_profile_id.lead_time_id.factor,
                    precision_rounding=rec.product_uom.rounding,
                )
                # Using minimum order quantity
                rec.green_zone_moq = float_round(
                    rec.minimum_order_quantity,
                    precision_rounding=rec.product_uom.rounding,
                )

                # The biggest option of the above will be used as the green
                # zone value
                rec.green_zone_qty = max(
                    rec.green_zone_oc, rec.green_zone_lt_factor, rec.green_zone_moq
                )
            else:
                rec.green_zone_qty = rec.green_override
            rec.top_of_green = rec.green_zone_qty + rec.top_of_yellow

    @api.depends(
        "dlt",
        "adu",
        "buffer_profile_id.lead_time_id.factor",
        "buffer_profile_id.variability_id.factor",
        "buffer_profile_id.replenish_method",
        "order_cycle",
        "minimum_order_quantity",
        "product_uom.rounding",
        "yellow_override",
        "red_zone_qty",
    )
    def _compute_yellow_zone(self):
        for rec in self:
            if rec.replenish_method == "min_max":
                rec.yellow_zone_qty = 0
            elif rec.replenish_method == "replenish":
                rec.yellow_zone_qty = float_round(
                    rec.dlt * rec.adu, precision_rounding=rec.product_uom.rounding
                )
            else:
                rec.yellow_zone_qty = rec.yellow_override
            rec.top_of_yellow = rec.yellow_zone_qty + rec.red_zone_qty

    @api.depends(
        "net_flow_position",
        "top_of_green",
        "qty_multiple",
        "product_uom",
        "procure_uom_id",
        "product_uom.rounding",
    )
    def _compute_procure_recommended_qty(self):
        subtract_qty = self.sudo()._quantity_in_progress()
        for rec in self:
            procure_recommended_qty = 0.0
            if rec.net_flow_position < rec.top_of_yellow:
                qty = rec.top_of_green - rec.net_flow_position - subtract_qty[rec.id]
                if qty >= 0.0:
                    procure_recommended_qty = qty
            else:
                if subtract_qty[rec.id] > 0.0:
                    procure_recommended_qty -= subtract_qty[rec.id]

            adjusted_qty = 0.0
            if procure_recommended_qty > 0.0:
                adjusted_qty = rec._adjust_procure_qty(procure_recommended_qty)
            rec.procure_recommended_qty = adjusted_qty

    def _adjust_procure_qty(self, qty):
        self.ensure_one()
        # If there is a procure UoM we apply it before anything.
        # This means max, min and multiple quantities are relative to
        # the procure UoM.
        if self.procure_uom_id:
            rounding = self.procure_uom_id.rounding
            adjusted_qty = self.product_id.uom_id._compute_quantity(
                qty, self.procure_uom_id
            )
        else:
            rounding = self.product_uom.rounding
            adjusted_qty = qty

        # Apply qty multiple and minimum quantity (maximum quantity
        # applies on the procure wizard)
        remainder = self.qty_multiple > 0 and adjusted_qty % self.qty_multiple or 0.0
        if float_compare(remainder, 0.0, precision_rounding=rounding) > 0:
            adjusted_qty += self.qty_multiple - remainder
        if (
            float_compare(
                adjusted_qty, self.procure_min_qty, precision_rounding=rounding
            )
            < 0
        ):
            adjusted_qty = self.procure_min_qty
        return adjusted_qty

    def _compute_ddmrp_chart(self):
        """This method use the Bokeh library to create a buffer depiction."""
        for rec in self:
            rec.ddmrp_chart = "%s%s" % rec.get_ddmrp_chart()

    def get_ddmrp_chart(self):
        p = figure(plot_width=300, plot_height=400, y_axis_label="Quantity")
        p.xaxis.visible = False
        p.toolbar.logo = None
        red = p.vbar(
            x=1, bottom=0, top=self.top_of_red, width=1, color="red", legend=False
        )
        yellow = p.vbar(
            x=1,
            bottom=self.top_of_red,
            top=self.top_of_yellow,
            width=1,
            color="yellow",
            legend=False,
        )
        green = p.vbar(
            x=1,
            bottom=self.top_of_yellow,
            top=self.top_of_green,
            width=1,
            color="green",
            legend=False,
        )
        net_flow = p.line(
            [0, 2], [self.net_flow_position, self.net_flow_position], line_width=2
        )
        on_hand = p.line(
            [0, 2],
            [self.product_location_qty, self.product_location_qty],
            line_width=2,
            line_dash="dotted",
        )
        legend = Legend(
            items=[
                ("Red zone", [red]),
                ("Yellow zone", [yellow]),
                ("Green zone", [green]),
                ("Net Flow Position", [net_flow]),
                ("On-Hand Position", [on_hand]),
            ]
        )
        labels_source_data = {
            "height": [
                self.net_flow_position,
                self.product_location_qty,
                self.top_of_red,
                self.top_of_yellow,
                self.top_of_green,
            ],
            "weight": [0.25, 1.75, 1, 1, 1],
            "names": [
                self.net_flow_position,
                self.product_location_qty,
                self.top_of_red,
                self.top_of_yellow,
                self.top_of_green,
            ],
        }
        source = ColumnDataSource(data=labels_source_data)
        labels = LabelSet(
            x="weight",
            y="height",
            text="names",
            y_offset=1,
            render_mode="canvas",
            text_font_size="8pt",
            source=source,
            text_align="center",
        )
        p.add_layout(labels)
        p.add_layout(legend, "below")

        script, div = components(p)
        return div, script

    def _compute_ddmrp_demand_supply_chart(self):
        for rec in self:
            if not rec.buffer_profile_id:
                # Not a buffer, skip.
                rec.ddmrp_demand_chart = ""
                rec.ddmrp_supply_chart = ""
                continue

            # Prepare data:
            demand_data = rec._get_demand_by_days()
            mrp_data = rec._get_qualified_mrp_moves()
            supply_data = rec._get_incoming_by_days()
            width = timedelta(days=0.4)
            date_format = self.env["res.lang"]._lang_get(self.env.lang).date_format

            # Plot demand data:
            if demand_data or mrp_data:
                x_demand = list(demand_data.keys())
                y_demand = list(demand_data.values())
                x_mrp = list(mrp_data.keys())
                y_mrp = list(mrp_data.values())

                p = figure(
                    plot_width=500,
                    plot_height=400,
                    y_axis_label="Quantity",
                    x_axis_type="datetime",
                )
                p.toolbar.logo = None
                p.sizing_mode = "stretch_both"
                # TODO: # p.xaxis.label_text_font = "helvetica"
                p.xaxis.formatter = DatetimeTickFormatter(
                    hours=date_format,
                    days=date_format,
                    months=date_format,
                    years=date_format,
                )
                p.xaxis.major_label_orientation = pi / 4

                if demand_data:
                    p.vbar(
                        x=x_demand,
                        width=width,
                        bottom=0,
                        top=y_demand,
                        color="firebrick",
                    )
                if mrp_data:
                    p.vbar(
                        x=x_mrp, width=width, bottom=0, top=y_mrp, color="lightsalmon"
                    )
                p.line(
                    [
                        datetime.today() - timedelta(days=1),
                        datetime.today() + timedelta(days=rec.order_spike_horizon),
                    ],
                    [rec.order_spike_threshold, rec.order_spike_threshold],
                    line_width=2,
                    line_dash="dashed",
                )

                unit = rec.product_uom.name
                hover = HoverTool(
                    tooltips=[("qty", "$y %s" % unit)], point_policy="follow_mouse"
                )
                p.add_tools(hover)

                script, div = components(p)
                rec.ddmrp_demand_chart = "{}{}".format(div, script)
            else:
                rec.ddmrp_demand_chart = _("No demand detected.")

            # Plot supply data:
            if supply_data:
                x_supply = list(supply_data.keys())
                y_supply = list(supply_data.values())

                p = figure(
                    plot_width=500,
                    plot_height=400,
                    y_axis_label="Quantity",
                    x_axis_type="datetime",
                )
                p.toolbar.logo = None
                p.sizing_mode = "stretch_both"
                p.xaxis.formatter = DatetimeTickFormatter(
                    hours=date_format,
                    days=date_format,
                    months=date_format,
                    years=date_format,
                )
                p.xaxis.major_label_orientation = pi / 4
                p.x_range.flipped = True

                # White line to have similar proportion to demand chart.
                p.line(
                    [
                        datetime.today() - timedelta(days=1),
                        datetime.today() + timedelta(days=rec.order_spike_horizon),
                    ],
                    [rec.order_spike_threshold, rec.order_spike_threshold],
                    line_width=2,
                    line_dash="dashed",
                    color="white",
                )

                p.vbar(x=x_supply, width=width, bottom=0, top=y_supply, color="grey")

                unit = rec.product_uom.name
                hover = HoverTool(
                    tooltips=[("qty", "$y %s" % unit)], point_policy="follow_mouse"
                )
                p.add_tools(hover)

                script, div = components(p)
                rec.ddmrp_supply_chart = "{}{}".format(div, script)
            else:
                rec.ddmrp_supply_chart = _("No supply detected.")

    @api.depends("red_zone_qty")
    def _compute_order_spike_threshold(self):
        for rec in self:
            rec.order_spike_threshold = 0.5 * rec.red_zone_qty

    def _get_manufactured_bom(self):
        return self.env["mrp.bom"].search(
            [
                "|",
                ("product_id", "=", self.product_id.id),
                ("product_tmpl_id", "=", self.product_id.product_tmpl_id.id),
                "|",
                ("location_id", "=", self.location_id.id),
                ("location_id", "=", False),
            ],
            limit=1,
        )

    @api.depends("lead_days", "product_id.seller_ids.delay")
    def _compute_dlt(self):
        for rec in self:
            if rec.buffer_profile_id.item_type == "manufactured":
                bom = rec._get_manufactured_bom()
                rec.dlt = bom.dlt
            elif rec.buffer_profile_id.item_type == "distributed":
                rec.dlt = rec.lead_days
            else:
                rec.dlt = (
                    rec.product_id.seller_ids
                    and rec.product_id.seller_ids[0].delay
                    or rec.lead_days
                )

    @api.depends("buffer_profile_id", "product_id.seller_ids")
    def _compute_main_supplier(self):
        for rec in self:
            if rec.item_type == "purchased":
                suppliers = rec.product_id.seller_ids.filtered(
                    lambda r: (not r.product_id or r.product_id == rec.product_id)
                    and (not r.company_id or r.company_id == rec.company_id)
                )
                rec.main_supplier_id = suppliers[0].name if suppliers else False
            else:
                rec.main_supplier_id = False

    buffer_profile_id = fields.Many2one(
        comodel_name="stock.buffer.profile", string="Buffer Profile", required=True,
    )
    replenish_method = fields.Selection(related="buffer_profile_id.replenish_method",)
    item_type = fields.Selection(related="buffer_profile_id.item_type",)
    main_supplier_id = fields.Many2one(
        comodel_name="res.partner",
        string="Main Supplier",
        compute="_compute_main_supplier",
        store=True,
        index=True,
    )
    green_override = fields.Float(string="Green Zone (Override)",)
    yellow_override = fields.Float(string="Yellow Zone (Override)",)
    red_override = fields.Float(string="Red Zone (Override)",)
    dlt = fields.Float(
        string="DLT (days)", compute="_compute_dlt", help="Decoupled Lead Time (days)",
    )
    adu = fields.Float(
        string="ADU",
        default=0.0,
        digits="Product Unit of Measure",
        readonly=True,
        help="Average Daily Usage",
    )
    adu_calculation_method = fields.Many2one(
        comodel_name="product.adu.calculation.method",
        string="ADU calculation method",
        required=True,
    )
    adu_calculation_method_type = fields.Selection(
        related="adu_calculation_method.method",
    )
    adu_fixed = fields.Float(
        string="Fixed ADU", default=1.0, digits="Product Unit of Measure",
    )
    order_cycle = fields.Float(string="Minimum Order Cycle (days)")
    minimum_order_quantity = fields.Float(
        string="Minimum Order Quantity", digits="Product Unit of Measure",
    )
    red_base_qty = fields.Float(
        string="Red Base Qty",
        compute="_compute_red_zone",
        digits="Product Unit of Measure",
        store=True,
    )
    red_safety_qty = fields.Float(
        string="Red Safety Qty",
        compute="_compute_red_zone",
        digits="Product Unit of Measure",
        store=True,
    )
    red_zone_qty = fields.Float(
        string="Red Zone Qty",
        compute="_compute_red_zone",
        digits="Product Unit of Measure",
        store=True,
    )
    top_of_red = fields.Float(string="Top of Red", related="red_zone_qty", store=True,)
    green_zone_qty = fields.Float(
        string="Green Zone Qty",
        compute="_compute_green_zone",
        digits="Product Unit of Measure",
        store=True,
    )
    green_zone_lt_factor = fields.Float(
        string="Green Zone Lead Time Factor",
        compute="_compute_green_zone",
        store=True,
        help="Green zone Lead Time Factor",
    )
    green_zone_moq = fields.Float(
        string="Green Zone Minimum Order Quantity",
        compute="_compute_green_zone",
        digits="Product Unit of Measure",
        store=True,
        help="Green zone qty option considering minimum order quantity",
    )
    green_zone_oc = fields.Float(
        string="Green Zone Order Cycle",
        compute="_compute_green_zone",
        store=True,
        help="Green zone qty option considering desired Order Cycle",
    )
    yellow_zone_qty = fields.Float(
        string="Yellow Zone Qty",
        compute="_compute_yellow_zone",
        digits="Product Unit of Measure",
        store=True,
    )
    top_of_yellow = fields.Float(
        string="Top of Yellow",
        compute="_compute_yellow_zone",
        digits="Product Unit of Measure",
        store=True,
    )
    top_of_green = fields.Float(
        string="Top of Green",
        compute="_compute_green_zone",
        digits="Product Unit of Measure",
        store=True,
    )
    order_spike_horizon = fields.Float(string="Order Spike Horizon")
    order_spike_threshold = fields.Float(
        string="Order Spike Threshold",
        compute="_compute_order_spike_threshold",
        digits="Product Unit of Measure",
        store=True,
    )
    qualified_demand = fields.Float(
        string="Qualified demand", digits="Product Unit of Measure", readonly=True,
    )
    incoming_dlt_qty = fields.Float(string="Incoming (Within DLT)", readonly=True,)
    net_flow_position = fields.Float(
        string="Net flow position", digits="Product Unit of Measure", readonly=True,
    )
    net_flow_position_percent = fields.Float(
        string="Net flow position (% of TOG)", readonly=True,
    )
    planning_priority_level = fields.Selection(
        string="Planning Priority Level", selection=_PRIORITY_LEVEL, readonly=True,
    )
    execution_priority_level = fields.Selection(
        string="On-Hand Alert Level",
        selection=_PRIORITY_LEVEL,
        store=True,
        readonly=True,
    )
    on_hand_percent = fields.Float(string="On Hand/TOR (%)", store=True, readonly=True,)
    mrp_production_ids = fields.One2many(
        string="Manufacturing Orders",
        comodel_name="mrp.production",
        inverse_name="buffer_id",
    )
    ddmrp_chart = fields.Text(string="DDMRP Chart", compute=_compute_ddmrp_chart,)
    ddmrp_demand_chart = fields.Text(
        string="DDMRP Demand Chart", compute="_compute_ddmrp_demand_supply_chart",
    )
    ddmrp_supply_chart = fields.Text(
        string="DDMRP Supply Chart", compute="_compute_ddmrp_demand_supply_chart",
    )

    @api.onchange("adu_fixed", "adu_calculation_method")
    def onchange_adu(self):
        self._calc_adu()

    def _search_open_stock_moves_domain(self):
        self.ensure_one()
        return [
            ("product_id", "=", self.product_id.id),
            ("state", "in", ["draft", "waiting", "confirmed", "assigned"]),
            ("location_dest_id", "=", self.location_id.id),
        ]

    @api.model
    def _stock_move_tree_view(self, lines):
        views = []
        tree_view = self.env.ref("stock.view_move_tree", False)
        if tree_view:
            views += [(tree_view.id, "tree")]
        form_view = self.env.ref("stock.view_move_form", False)
        if form_view:
            views += [(form_view.id, "form")]

        return {
            "name": _("Non-completed Moves"),
            "type": "ir.actions.act_window",
            "res_model": "stock.move",
            "view_type": "form",
            "views": views,
            "view_mode": "tree,form",
            "domain": str([("id", "in", lines.ids)]),
        }

    def open_moves(self):
        self.ensure_one()
        # Utility method used to add an "Open Moves" button in the buffer
        # planning view
        domain = self._search_open_stock_moves_domain()
        records = self.env["stock.move"].search(domain)
        return self._stock_move_tree_view(records)

    def _past_demand_estimate_domain(self, date_from, date_to, locations):
        self.ensure_one()
        return [
            ("location_id", "in", locations.ids),
            ("product_id", "=", self.product_id.id),
            ("date_from", "<=", date_to),
            ("date_to", ">=", date_from),
        ]

    def _past_moves_domain(self, date_from, date_to, locations):
        self.ensure_one()
        return [
            ("state", "=", "done"),
            ("location_id", "in", locations.ids),
            ("location_dest_id", "not in", locations.ids),
            ("product_id", "=", self.product_id.id),
            ("date", ">=", date_from),
            ("date", "<=", date_to),
        ]

    def _calc_adu_past_demand(self):
        self.ensure_one()
        horizon = self.adu_calculation_method.horizon_past or 0
        # today is excluded to be sure that is a past day and all moves
        # for that day are done (or at least the expected date is in the past).
        date_from = fields.Date.to_string(
            self.warehouse_id.wh_plan_days(datetime.now(), -1 * horizon)
        )
        date_to = fields.Date.to_string(
            self.warehouse_id.wh_plan_days(datetime.now(), -1)
        )
        locations = self.env["stock.location"].search(
            [("id", "child_of", [self.location_id.id])]
        )
        if self.adu_calculation_method.source_past == "estimates":
            qty = 0.0
            domain = self._past_demand_estimate_domain(date_from, date_to, locations)
            for estimate in self.env["stock.demand.estimate"].search(domain):
                qty += estimate.get_quantity_by_date_range(
                    fields.Date.from_string(date_from), fields.Date.from_string(date_to)
                )
            return qty / horizon
        elif self.adu_calculation_method.source_past == "actual":
            qty = 0.0
            domain = self._past_moves_domain(date_from, date_to, locations)
            for group in self.env["stock.move"].read_group(
                domain, ["product_id", "product_qty"], ["product_id"]
            ):
                qty += group["product_qty"]
            return qty / horizon
        else:
            return 0.0

    def _future_demand_estimate_domain(self, date_from, date_to, locations):
        self.ensure_one()
        return [
            ("location_id", "in", locations.ids),
            ("product_id", "=", self.product_id.id),
            ("date_from", "<=", date_to),
            ("date_to", ">=", date_from),
        ]

    def _future_moves_domain(self, date_from, date_to, locations):
        self.ensure_one()
        return [
            ("state", "not in", ["done", "cancel"]),
            ("location_id", "in", locations.ids),
            ("location_dest_id", "not in", locations.ids),
            ("product_id", "=", self.product_id.id),
            ("date_expected", ">=", date_from),
            ("date_expected", "<=", date_to),
        ]

    def _calc_adu_future_demand(self):
        self.ensure_one()
        horizon = self.adu_calculation_method.horizon_future or 1
        date_from = fields.Datetime.now()
        date_to = self.warehouse_id.wh_plan_days(date_from, horizon)
        date_to = date_to.replace(
            hour=date_from.hour, minute=date_from.minute, second=date_from.second,
        )
        locations = self.env["stock.location"].search(
            [("id", "child_of", [self.location_id.id])]
        )
        if self.adu_calculation_method.source_future == "estimates":
            qty = 0.0
            domain = self._future_demand_estimate_domain(date_from, date_to, locations)
            for estimate in self.env["stock.demand.estimate"].search(domain):
                qty += estimate.get_quantity_by_date_range(
                    fields.Date.from_string(date_from), fields.Date.from_string(date_to)
                )
            return qty / horizon
        elif self.adu_calculation_method.source_future == "actual":
            qty = 0.0
            domain = self._future_moves_domain(date_from, date_to, locations)
            for group in self.env["stock.move"].read_group(
                domain, ["product_id", "product_qty"], ["product_id"]
            ):
                qty += group["product_qty"]
            return qty / horizon
        else:
            return 0.0

    def _calc_adu_blended(self):
        self.ensure_one()
        past_comp = self._calc_adu_past_demand()
        fp = self.adu_calculation_method.factor_past
        future_comp = self._calc_adu_future_demand()
        ff = self.adu_calculation_method.factor_future
        return past_comp * fp + future_comp * ff

    def _calc_adu(self):
        for rec in self:
            if rec.adu_calculation_method.method == "fixed":
                rec.adu = rec.adu_fixed
            elif rec.adu_calculation_method.method == "past":
                rec.adu = rec._calc_adu_past_demand()
            elif rec.adu_calculation_method.method == "future":
                rec.adu = rec._calc_adu_future_demand()
            elif rec.adu_calculation_method.method == "blended":
                rec.adu = rec._calc_adu_blended()
        return True

    def _search_stock_moves_qualified_demand_domain(self):
        self.ensure_one()
        horizon = self.order_spike_horizon
        date_to = self.warehouse_id.wh_plan_days(datetime.now(), horizon)
        locations = self.env["stock.location"].search(
            [("id", "child_of", [self.location_id.id])]
        )
        return [
            ("product_id", "=", self.product_id.id),
            ("state", "in", ["waiting", "confirmed", "assigned"]),
            ("location_id", "in", locations.ids),
            ("location_dest_id", "not in", locations.ids),
            ("date_expected", "<=", date_to),
        ]

    def _search_stock_moves_incoming_domain(self):
        self.ensure_one()
        # We introduce a safety factor of 2 for incoming moves
        factor = self.warehouse_id.nfp_incoming_safety_factor or 1
        horizon = int(self.dlt) * factor
        # For purchased products we use calendar days, not work days
        if (
            self.warehouse_id.calendar_id
            and self.buffer_profile_id.item_type != "purchased"
        ):
            date_to = self.warehouse_id.wh_plan_days(datetime.now(), horizon)
        else:
            date_to = fields.Date.to_string(
                fields.date.today() + timedelta(days=horizon)
            )
        locations = self.env["stock.location"].search(
            [("id", "child_of", [self.location_id.id])]
        )
        return [
            ("product_id", "=", self.product_id.id),
            ("state", "in", ["waiting", "confirmed", "assigned"]),
            ("location_id", "not in", locations.ids),
            ("location_dest_id", "in", locations.ids),
            ("date_expected", "<=", date_to),
        ]

    def _get_incoming_by_days(self):
        self.ensure_one()
        incoming_dom = self._search_stock_moves_incoming_domain()
        moves = self.env["stock.move"].search(incoming_dom)
        incoming_by_days = {}
        move_dates = [dt.date() for dt in moves.mapped("date_expected")]
        for move_date in move_dates:
            incoming_by_days[move_date] = 0.0
        for move in moves:
            date = move.date_expected.date()
            incoming_by_days[date] += move.product_qty
        return incoming_by_days

    def _get_demand_by_days(self):
        self.ensure_one()
        domain = self._search_stock_moves_qualified_demand_domain()
        moves = self.env["stock.move"].search(domain)
        demand_by_days = {}
        move_dates = [dt.date() for dt in moves.mapped("date_expected")]
        for move_date in move_dates:
            demand_by_days[move_date] = 0.0
        for move in moves:
            date = move.date_expected.date()
            demand_by_days[date] += move.product_qty - move.reserved_availability
        return demand_by_days

    def _search_mrp_moves_qualified_demand_domain(self):
        self.ensure_one()
        horizon = self.order_spike_horizon
        date_to = self.warehouse_id.wh_plan_days(datetime.now(), horizon)
        locations = self.env["stock.location"].search(
            [("id", "child_of", [self.location_id.id])]
        )
        return [
            ("product_id", "=", self.product_id.id),
            ("mrp_area_id.location_id", "in", locations.ids),
            ("mrp_type", "=", "d"),
            ("mrp_date", "<=", date_to),
        ]

    def _get_qualified_mrp_moves(self):
        self.ensure_one()
        domain = self._search_mrp_moves_qualified_demand_domain()
        moves = self.env["mrp.move"].search(domain)
        mrp_moves_by_days = {}
        move_dates = [dt for dt in moves.mapped("mrp_date")]
        for move_date in move_dates:
            mrp_moves_by_days[move_date] = 0.0
        for move in moves:
            date = move.mrp_date
            mrp_moves_by_days[date] += abs(move.mrp_qty)
        return mrp_moves_by_days

    def _calc_qualified_demand(self, current_date=False):
        today = current_date or fields.date.today()
        for rec in self:
            rec.qualified_demand = 0.0
            demand_by_days = rec._get_demand_by_days()
            mrp_moves_by_days = rec._get_qualified_mrp_moves()
            dates = list(set(demand_by_days.keys()) | set(mrp_moves_by_days.keys()))
            for date in dates:
                if (
                    demand_by_days.get(date, 0.0) >= rec.order_spike_threshold
                    or date <= today
                ):
                    rec.qualified_demand += demand_by_days.get(date, 0.0)
                if (
                    mrp_moves_by_days.get(date, 0.0) >= rec.order_spike_threshold
                    or date <= today
                ):
                    rec.qualified_demand += mrp_moves_by_days.get(date, 0.0)
        return True

    def _calc_incoming_dlt_qty(self):
        for rec in self:
            rec.incoming_dlt_qty = 0.0
            domain = rec._search_stock_moves_incoming_domain()
            moves = self.env["stock.move"].search(domain)
            rec.incoming_dlt_qty = sum(moves.mapped("product_qty"))
        return True

    def _calc_net_flow_position(self):
        for rec in self:
            rec.net_flow_position = (
                rec.product_location_qty_available_not_res
                + rec.incoming_dlt_qty
                - rec.qualified_demand
            )
            usage = 0.0
            if rec.top_of_green:
                usage = round((rec.net_flow_position / rec.top_of_green * 100), 2)
            rec.net_flow_position_percent = usage
        return True

    def _calc_planning_priority(self):
        for rec in self:
            if rec.net_flow_position >= rec.top_of_yellow:
                rec.planning_priority_level = "3_green"
            elif rec.net_flow_position >= rec.top_of_red:
                rec.planning_priority_level = "2_yellow"
            else:
                rec.planning_priority_level = "1_red"

    def _calc_execution_priority(self):
        for rec in self:
            if rec.product_location_qty_available_not_res >= rec.top_of_red:
                rec.execution_priority_level = "3_green"
            elif rec.product_location_qty_available_not_res >= rec.top_of_red * 0.5:
                rec.execution_priority_level = "2_yellow"
            else:
                rec.execution_priority_level = "1_red"
            if rec.top_of_red:
                rec.on_hand_percent = round(
                    (
                        (rec.product_location_qty_available_not_res / rec.top_of_red)
                        * 100
                    ),
                    2,
                )
            else:
                rec.on_hand_percent = 0.0

    def write(self, vals):
        res = super().write(vals)
        if any(f in vals for f in ("adu_fixed", "adu_calculation_method")):
            self._calc_adu()
        return res

    @api.model
    def cron_ddmrp_adu(self, automatic=False):
        """calculate ADU for each DDMRP buffer. Called by cronjob."""
        _logger.info("Start cron_ddmrp_adu.")
        buffers = self.search([])
        i = 0
        j = len(buffers)
        for b in buffers:
            try:
                i += 1
                _logger.debug("ddmrp cron_adu: {}. ({}/{})".format(b.name, i, j))
                if automatic:
                    with self.env.cr.savepoint():
                        b._calc_adu()
                else:
                    b._calc_adu()
            except Exception:
                _logger.exception("Fail to compute ADU for buffer %s", b.name)
                if not automatic:
                    raise
        _logger.info("End cron_ddmrp_adu.")
        return True

    def cron_actions(self, only_nfp=False):
        """This method is meant to be inherited by other modules in order to
        enhance extensibility."""
        self.ensure_one()
        if not only_nfp or only_nfp == "out":
            self._calc_qualified_demand()
        if not only_nfp or only_nfp == "in":
            self._calc_incoming_dlt_qty()
        self._calc_net_flow_position()
        self._calc_planning_priority()
        self._calc_execution_priority()
        self.mrp_production_ids._calc_execution_priority()
        self.mapped("purchase_line_ids")._calc_execution_priority()
        if not only_nfp:
            # re-compoute red to force in cascade the recalculation of zones.
            self._compute_red_zone()
        return True

    @api.model
    def cron_ddmrp(self, automatic=False):
        """Calculate key DDMRP parameters for each buffer.
        Called by cronjob."""
        _logger.info("Start cron_ddmrp.")
        buffers = self.search([])
        i = 0
        j = len(buffers)
        buffers.refresh()
        for b in buffers:
            i += 1
            _logger.debug("ddmrp cron: {}. ({}/{})".format(b.name, i, j))
            try:
                if automatic:
                    with self.env.cr.savepoint():
                        b.cron_actions()
                else:
                    b.cron_actions()
            except Exception:
                _logger.exception("Fail updating buffer %s", b.name)
                if not automatic:
                    raise
        _logger.info("End cron_ddmrp.")
        return True
